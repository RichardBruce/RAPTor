<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Test Coverage - physics_engine/vertex_group.cc</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">physics_engine</a> - vertex_group.cc<span style="font-size: 80%;"> (source / <a href="vertex_group.cc.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Test Coverage</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">100</td>
            <td class="headerCovTableEntry">224</td>
            <td class="headerCovTableEntryLo">44.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2014-01-16</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntryMed">84.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : </a>
<span class="lineNum">       2 </span>            : /* Standard headers */
<span class="lineNum">       3 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">       4 </span>            : #include &lt;limits&gt;
<span class="lineNum">       5 </span>            : #include &lt;memory&gt;
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /* Physics headers */
<span class="lineNum">       8 </span>            : #include &quot;physics_common.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;vertex_group.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;gjk.h&quot;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : /* Shared headers */
<span class="lineNum">      13 </span>            : #include &quot;point_t.h&quot;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : namespace raptor_physics
<span class="lineNum">      17 </span>            : {
<span class="lineNum">      18 </span><span class="lineCov">        480 : bool vertex_group::has_collided(vertex_group *const vg, simplex **const manifold_a, </span>
<span class="lineNum">      19 </span>            :     simplex **const manifold_b, point_t *const d, const fp_t t0, const fp_t t1, const bool force_disp)
<span class="lineNum">      20 </span>            : {
<span class="lineNum">      21 </span><span class="lineCov">        480 :     METHOD_LOG;</span>
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            :     /* Check for self intersection and return an empty simplex */
<span class="lineNum">      24 </span><span class="lineCov">        480 :     if (vg == this)</span>
<span class="lineNum">      25 </span>            :     {
<span class="lineNum">      26 </span><span class="lineNoCov">          0 :         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Ignoring self collision&quot;;</span>
<span class="lineNum">      27 </span><span class="lineNoCov">          0 :         *manifold_a = new simplex(*_verts);</span>
<span class="lineNum">      28 </span><span class="lineNoCov">          0 :         *manifold_b = new simplex(*(vg-&gt;_verts));</span>
<span class="lineNum">      29 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">      30 </span>            :     }
<span class="lineNum">      31 </span>            :     
<span class="lineNum">      32 </span>            :     /* Pass verts to the GJK algorithm */
<span class="lineNum">      33 </span><span class="lineCov">        960 :     gjk tester((*_verts), (*vg-&gt;_verts), force_disp);</span>
<span class="lineNum">      34 </span>            :     
<span class="lineNum">      35 </span>            :     /* Calculate the relative displacement */
<span class="lineNum">      36 </span><span class="lineCov">        480 :     const point_t rel_disp0(force_disp ? point_t(0.0, 0.0, 0.0) : (project_translation(t0) - vg-&gt;project_translation(t0)));</span>
<span class="lineNum">      37 </span><span class="lineCov">        480 :     const point_t rel_disp1(project_translation(t1) - vg-&gt;project_translation(t1));</span>
<span class="lineNum">      38 </span><span class="lineCov">        960 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Relative displacement: &quot; &lt;&lt; rel_disp0 &lt;&lt; &quot; -&gt; &quot; &lt;&lt; rel_disp1;</span>
<span class="lineNum">      39 </span>            :     
<span class="lineNum">      40 </span>            :     /* Test for collision */
<span class="lineNum">      41 </span><span class="lineCov">        480 :     const bool collided = tester.find_minimum_distance(d, rel_disp0, rel_disp1 - rel_disp0, force_disp);</span>
<span class="lineNum">      42 </span><span class="lineCov">        480 :     (*manifold_a) = tester.get_simplex_a();</span>
<span class="lineNum">      43 </span><span class="lineCov">        480 :     (*manifold_b) = tester.get_simplex_b();</span>
<span class="lineNum">      44 </span><span class="lineCov">        960 :     return collided;</span>
<span class="lineNum">      45 </span>            : }
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : /* TODO -- There has to be a faster way to handle objects in resting contact */
<span class="lineNum">      49 </span>            : /* TODO -- Re-write using POSSIBLY_ to avoid some full collision detection */
<span class="lineNum">      50 </span><span class="lineCov">        444 : collision_t vertex_group::exactly_resolve_collisions(vertex_group *const vg, simplex **const manifold_a, simplex **const manifold_b, fp_t *const t)</span>
<span class="lineNum">      51 </span>            : {
<span class="lineNum">      52 </span><span class="lineCov">        444 :     METHOD_LOG;</span>
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            :     /* Check for self intersection and return an empty simplex */
<span class="lineNum">      55 </span><span class="lineCov">        444 :     if (vg == this)</span>
<span class="lineNum">      56 </span>            :     {
<span class="lineNum">      57 </span><span class="lineCov">        240 :         *manifold_a = new simplex(*_verts);</span>
<span class="lineNum">      58 </span><span class="lineCov">        240 :         *manifold_b = new simplex(*(vg-&gt;_verts));</span>
<span class="lineNum">      59 </span><span class="lineCov">        240 :         return NO_COLLISION;</span>
<span class="lineNum">      60 </span>            :     }
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span><span class="lineCov">        204 :     const fp_t min_t = std::max(_cur_t, vg-&gt;_cur_t);</span>
<span class="lineNum">      63 </span><span class="lineCov">        204 :     const fp_t max_t = *t;</span>
<span class="lineNum">      64 </span><span class="lineCov">        408 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Solving within time range: &quot; &lt;&lt; min_t &lt;&lt; &quot; to &quot; &lt;&lt; max_t;</span>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :     /* Test at start position */
<span class="lineNum">      67 </span><span class="lineCov">        204 :     point_t dir1;</span>
<span class="lineNum">      68 </span><span class="lineCov">        204 :     has_collided(vg, manifold_a, manifold_b, &amp;dir1, min_t, min_t, false);</span>
<span class="lineNum">      69 </span><span class="lineCov">        204 :     const fp_t d_t0 = magnitude(dir1);</span>
<span class="lineNum">      70 </span><span class="lineCov">        204 :     delete *manifold_a;</span>
<span class="lineNum">      71 </span><span class="lineCov">        204 :     delete *manifold_b;</span>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            :     /* Test during time period, note d_t1 &lt;= dt_0 */
<span class="lineNum">      74 </span><span class="lineCov">        204 :     point_t dir;</span>
<span class="lineNum">      75 </span><span class="lineCov">        204 :     has_collided(vg, manifold_a, manifold_b, &amp;dir, min_t, max_t, false);</span>
<span class="lineNum">      76 </span><span class="lineCov">        204 :     fp_t d_t1 = magnitude(dir);</span>
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            :     /* The objects never get within weld ditance, all is well */
<span class="lineNum">      79 </span><span class="lineCov">        204 :     if (d_t1 &gt; raptor_physics::WELD_DISTANCE)</span>
<span class="lineNum">      80 </span>            :     {
<span class="lineNum">      81 </span><span class="lineCov">        312 :         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Object separate, no collision&quot;;</span>
<span class="lineNum">      82 </span><span class="lineCov">        156 :         return NO_COLLISION;</span>
<span class="lineNum">      83 </span>            :     }
<span class="lineNum">      84 </span>            :     /* The objects never get any closer, they are sliding or separating */
<span class="lineNum">      85 </span><span class="lineCov">         48 :     else if (fabs(d_t0 - d_t1) &lt; raptor_physics::EPSILON)</span>
<span class="lineNum">      86 </span>            :     {
<span class="lineNum">      87 </span><span class="lineCov">         48 :         has_collided(vg, manifold_a, manifold_b, &amp;dir, max_t, max_t, true);</span>
<span class="lineNum">      88 </span><span class="lineCov">         48 :         d_t1 = magnitude(dir);</span>
<span class="lineNum">      89 </span><span class="lineCov">         48 :         if (d_t1 &gt; raptor_physics::WELD_DISTANCE)</span>
<span class="lineNum">      90 </span>            :         {
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :             BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Object separating, no collision&quot;;</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :             return NO_COLLISION;</span>
<span class="lineNum">      93 </span>            :         }
<span class="lineNum">      94 </span>            :         /* The objects are already sliding */
<span class="lineNum">      95 </span>            :         else
<span class="lineNum">      96 </span>            :         {
<span class="lineNum">      97 </span><span class="lineCov">         96 :             BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Sliding collision&quot;;</span>
<span class="lineNum">      98 </span><span class="lineCov">         48 :             return SLIDING_COLLISION;</span>
<span class="lineNum">      99 </span>            :         }
<span class="lineNum">     100 </span>            :     }
<span class="lineNum">     101 </span>            :     /* If distance at t0 is within the weld distance (and dt1 is closer) it is about to slide */
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     else if (d_t0 &lt; raptor_physics::WELD_DISTANCE)</span>
<span class="lineNum">     103 </span>            :     {
<span class="lineNum">     104 </span>            :         /* Multiple collision may happen in the time step, but the times and distances are so small we just want to find one */
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :         fp_t t_lo   = min_t;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :         fp_t t_mid  = (min_t + max_t) * 0.5;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         fp_t t_hi   = max_t;</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :         int res_col_cnt = 0;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :         do</span>
<span class="lineNum">     110 </span>            :         {
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :             delete *manifold_a;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :             delete *manifold_b;</span>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :             BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Objects &quot; &lt;&lt; d_t0 &lt;&lt; &quot; (&quot; &lt;&lt; t_lo &lt;&lt; &quot;) apart and moving to &quot; &lt;&lt; t_hi &lt;&lt; &quot;(&quot; &lt;&lt; d_t1 &lt;&lt; &quot;)&quot;;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :             has_collided(vg, manifold_a, manifold_b, &amp;dir, t_mid, t_mid, true);</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :             const fp_t d_mid = magnitude(dir);</span>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :             if ((d_mid &gt; d_t0) &amp;&amp; (dot_product(dir1, dir) &gt; 0.0))</span>
<span class="lineNum">     119 </span>            :             {
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :                 t_lo = t_mid;</span>
<span class="lineNum">     121 </span>            :             }
<span class="lineNum">     122 </span>            :             else
<span class="lineNum">     123 </span>            :             {
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :                 t_hi = t_mid;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :                 d_t1 = d_mid;</span>
<span class="lineNum">     126 </span>            :             }
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :             t_mid = (t_lo + t_hi) * 0.5;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :             assert ((++res_col_cnt &lt; 1000) || !&quot;Error: Stuck in the sliding collision resolution loop&quot;);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :         } while (fabs(d_t0 - d_t1) &gt; raptor_physics::EPSILON);</span>
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :         *t = t_mid;</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Sliding collision about to happen at: &quot; &lt;&lt; t_mid;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :         return SLIDING_COLLISION;</span>
<span class="lineNum">     134 </span>            :     }
<span class="lineNum">     135 </span>            :     
<span class="lineNum">     136 </span>            :     /* There was a collision bring the objects in contact without penetrating each other */
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Objects started &quot; &lt;&lt; d_t0 &lt;&lt; &quot; (&quot; &lt;&lt; min_t &lt;&lt; &quot;) apart and collided by &quot; &lt;&lt; max_t &lt;&lt; &quot;(&quot; &lt;&lt; d_t1 &lt;&lt; &quot;)&quot;;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     int res_col_cnt = 0;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     std::pair&lt;fp_t, fp_t&gt; p_t0(min_t, d_t0);</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :     std::pair&lt;fp_t, fp_t&gt; p_t1(max_t, d_t1);</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     fp_t adjusted_t = (p_t0.first + p_t1.first) * 0.5;</span>
<span class="lineNum">     142 </span>            :     while (true)
<span class="lineNum">     143 </span>            :     {
<span class="lineNum">     144 </span>            :         /* Clean the last (no longer needed) manifolds */
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         delete *manifold_a;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         delete *manifold_b;</span>
<span class="lineNum">     147 </span>            :     
<span class="lineNum">     148 </span>            :         /* Test for collisions */
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :         const bool collided = has_collided(vg, manifold_a, manifold_b, &amp;dir, min_t, adjusted_t, false);</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :         d_t1 = magnitude(dir);</span>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         if ((d_t1 &gt; (0.25 * raptor_physics::WELD_DISTANCE)) &amp;&amp; (d_t1 &lt; raptor_physics::WELD_DISTANCE) &amp;&amp; ((d_t0 - d_t1) &gt; raptor_physics::EPSILON))</span>
<span class="lineNum">     153 </span>            :         {
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     155 </span>            :         }
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :         /* If the objects penetrate then rollback time */
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :         if (collided)</span>
<span class="lineNum">     159 </span>            :         {
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :             p_t1.first = adjusted_t;</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :             p_t1.second = d_t1;</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :             adjusted_t = (p_t0.first + p_t1.first) * 0.5;</span>
<span class="lineNum">     164 </span>            :         }
<span class="lineNum">     165 </span>            :         /* Else use the &quot;velocity&quot; to estimate a contact time */
<span class="lineNum">     166 </span>            :         else
<span class="lineNum">     167 </span>            :         {
<span class="lineNum">     168 </span>            :             /* Update p0 or p1 to keep the root bracketed */
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :             if (d_t1 &gt; (0.25 * raptor_physics::WELD_DISTANCE))</span>
<span class="lineNum">     170 </span>            :             {
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :                 p_t0.first = adjusted_t;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :                 p_t0.second = d_t1;</span>
<span class="lineNum">     173 </span>            :             }
<span class="lineNum">     174 </span>            :             else
<span class="lineNum">     175 </span>            :             {
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :                 p_t1.first = adjusted_t;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :                 p_t1.second = d_t1;</span>
<span class="lineNum">     178 </span>            :             }
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :             const fp_t disp = p_t0.second - p_t1.second;</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :             const fp_t move = d_t1 - (0.5 * raptor_physics::WELD_DISTANCE);</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :             const fp_t last_adj = ((p_t1.first - p_t0.first) / disp) * move;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :             adjusted_t = std::min(adjusted_t + last_adj, max_t);</span>
<span class="lineNum">     184 </span>            :         }
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :         assert(adjusted_t &gt; (min_t + raptor_physics::EPSILON));</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :         assert ((++res_col_cnt &lt; 1000) || !&quot;Error: Stuck in the collision resolution loop&quot;);</span>
<span class="lineNum">     187 </span>            :     }
<span class="lineNum">     188 </span>            :     
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     *t = adjusted_t;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     return COLLISION;</span>
<span class="lineNum">     191 </span>            : }
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span><span class="lineCov">         48 : collision_t vertex_group::conservatively_resolve_collisions(vertex_group *const vg, simplex **const manifold_a, simplex **const manifold_b, fp_t *const t)</span>
<span class="lineNum">     195 </span>            : {
<span class="lineNum">     196 </span><span class="lineCov">         48 :     METHOD_LOG;</span>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :     /* Check for self intersection and return an empty simplex */
<span class="lineNum">     199 </span><span class="lineCov">         48 :     if (vg == this)</span>
<span class="lineNum">     200 </span>            :     {
<span class="lineNum">     201 </span><span class="lineCov">         24 :         *manifold_a = new simplex(*_verts);</span>
<span class="lineNum">     202 </span><span class="lineCov">         24 :         *manifold_b = new simplex(*(vg-&gt;_verts));</span>
<span class="lineNum">     203 </span><span class="lineCov">         24 :         return NO_COLLISION;</span>
<span class="lineNum">     204 </span>            :     }
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineCov">         24 :     const fp_t min_t = std::max(_cur_t, vg-&gt;_cur_t);</span>
<span class="lineNum">     207 </span><span class="lineCov">         24 :     const fp_t max_t = *t;</span>
<span class="lineNum">     208 </span><span class="lineCov">         48 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Solving between &quot; &lt;&lt; min_t &lt;&lt; &quot; and &quot; &lt;&lt; max_t;</span>
<span class="lineNum">     209 </span>            : //    BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;w: &quot; &lt;&lt; _w.x &lt;&lt; &quot; &quot; &lt;&lt; _w.y &lt;&lt; &quot; &quot; &lt;&lt; _w.z;
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :     /* Check location at time 0, this test is exact because no movement is involved */
<span class="lineNum">     212 </span><span class="lineCov">         24 :     point_t dir;</span>
<span class="lineNum">     213 </span><span class="lineCov">         24 :     has_collided(vg, manifold_a, manifold_b, &amp;dir, min_t, min_t, false);</span>
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :     /* Retreive the distance between the objects and the closest points */
<span class="lineNum">     216 </span><span class="lineCov">         24 :     const fp_t d_t0 = magnitude(dir);</span>
<span class="lineNum">     217 </span><span class="lineCov">         48 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Initial separation: &quot; &lt;&lt; d_t0;</span>
<span class="lineNum">     218 </span><span class="lineCov">         24 :     assert((d_t0 &gt; raptor_physics::EPSILON) || !&quot;Error: Object must start separated&quot;);</span>
<span class="lineNum">     219 </span>            :     
<span class="lineNum">     220 </span><span class="lineCov">         24 :     const point_t p_a((*manifold_a)-&gt;get_vertex(0));</span>
<span class="lineNum">     221 </span><span class="lineCov">         24 :     const point_t p_b((*manifold_b)-&gt;get_vertex(0));</span>
<span class="lineNum">     222 </span>            : //    BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;closest point on a: &quot; &lt;&lt; p_a.x &lt;&lt; &quot; &quot; &lt;&lt; p_a.y &lt;&lt; &quot; &quot; &lt;&lt; p_a.z;
<span class="lineNum">     223 </span>            : //    BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;closest point on b: &quot; &lt;&lt; p_b.x &lt;&lt; &quot; &quot; &lt;&lt; p_b.y &lt;&lt; &quot; &quot; &lt;&lt; p_b.z;
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :     /* Check the worst case distance at max_t */
<span class="lineNum">     226 </span><span class="lineCov">         24 :     const point_t noc(dir / d_t0);</span>
<span class="lineNum">     227 </span><span class="lineCov">         24 :     const fp_t max_d = project_maximum_movement_onto((*vg), p_a, p_b, noc, max_t);</span>
<span class="lineNum">     228 </span><span class="lineCov">         24 :     fp_t d_t1 = d_t0 - max_d;</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :     /* Objects start in contact */
<span class="lineNum">     231 </span><span class="lineCov">         24 :     if (d_t0 &lt; raptor_physics::WELD_DISTANCE)</span>
<span class="lineNum">     232 </span>            :     {
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         if (d_t1 &lt; raptor_physics::WELD_DISTANCE)</span>
<span class="lineNum">     234 </span>            :         {
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :             return close_contact_collision_detection(vg, manifold_a, manifold_b, t, noc);</span>
<span class="lineNum">     236 </span>            :         }
<span class="lineNum">     237 </span>            :         /* Penetrates so impact at min_t */
<span class="lineNum">     238 </span>            :         // if (d_t1 &lt; (0.25 * raptor_physics::WELD_DISTANCE))
<span class="lineNum">     239 </span>            :         // {
<span class="lineNum">     240 </span>            :         //     (*t) = min_t;
<span class="lineNum">     241 </span>            :         //     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;resting collision: &quot; &lt;&lt; d_t1;
<span class="lineNum">     242 </span>            :         //     return RESTING_COLLISION;
<span class="lineNum">     243 </span>            :         // }
<span class="lineNum">     244 </span>            :         /* Sliding so impact at max_t */
<span class="lineNum">     245 </span>            :         // else if (d_t1 &lt; raptor_physics::WELD_DISTANCE)
<span class="lineNum">     246 </span>            :         // {
<span class="lineNum">     247 </span>            :         //     (*t) = max_t;
<span class="lineNum">     248 </span>            :         //     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;possible sliding: &quot; &lt;&lt; d_t1;
<span class="lineNum">     249 </span>            :         //     return POSSIBLE_SLIDING_COLLISION;
<span class="lineNum">     250 </span>            :         // }
<span class="lineNum">     251 </span>            :         /* Splitting */
<span class="lineNum">     252 </span>            :     }
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :     /* Never any contact or splitting */
<span class="lineNum">     255 </span><span class="lineCov">         24 :     if (d_t1 &gt; raptor_physics::WELD_DISTANCE)</span>
<span class="lineNum">     256 </span>            :     {
<span class="lineNum">     257 </span><span class="lineCov">         48 :         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;no collision &quot; &lt;&lt; d_t1;</span>
<span class="lineNum">     258 </span><span class="lineCov">         24 :         return NO_COLLISION;</span>
<span class="lineNum">     259 </span>            :     }
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :     /* Iterate until no contact possible */
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     int res_col_cnt = 0;</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     fp_t adjusted_t = max_t;</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     std::pair&lt;fp_t, fp_t&gt; p_t1;</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     std::pair&lt;fp_t, fp_t&gt; p_t0(min_t, d_t0);</span>
<span class="lineNum">     266 </span>            : //    BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;resolving collsion: &quot; &lt;&lt; d_t1 &lt;&lt; &quot; at: &quot; &lt;&lt; max_t;
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     do</span>
<span class="lineNum">     268 </span>            :     {
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         assert ((++res_col_cnt &lt; 1000) || !&quot;Error: Stuck in the collision resolution loop&quot;);</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :         /* Track the interval containing the collision */
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         if (d_t1 &lt; (0.25 * raptor_physics::WELD_DISTANCE))</span>
<span class="lineNum">     273 </span>            :         {
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :             p_t1.first = adjusted_t;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :             p_t1.second = d_t1;</span>
<span class="lineNum">     276 </span>            :         }
<span class="lineNum">     277 </span>            :         else
<span class="lineNum">     278 </span>            :         {
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :             p_t0.first = adjusted_t;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :             p_t0.second = d_t1;</span>
<span class="lineNum">     281 </span>            :         }
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :         /* Refine guess */
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         const fp_t vel = (p_t0.second - p_t1.second) / (p_t1.first - p_t0.first);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         const fp_t adj = d_t1 - (0.5 * raptor_physics::WELD_DISTANCE);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         adjusted_t += adj / vel;</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :         /* Get worst case movement at adjusted t */
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         const fp_t max_d = project_maximum_movement_onto((*vg), p_a, p_b, noc, adjusted_t);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :         /* Update worst case distance at adjusted t */
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         d_t1 = d_t0 - max_d;</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : //        BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;vel: &quot; &lt;&lt; vel &lt;&lt; &quot; dist: &quot; &lt;&lt; d_t1 &lt;&lt; &quot; at: &quot; &lt;&lt; adjusted_t;
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     } while ((d_t1 &lt; (0.25 * raptor_physics::WELD_DISTANCE)) || (d_t1 &gt; raptor_physics::WELD_DISTANCE));</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     (*t) = adjusted_t;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;possible collision at: &quot; &lt;&lt; adjusted_t &lt;&lt; &quot; dist: &quot; &lt;&lt; d_t1;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     return POSSIBLE_COLLISION;</span>
<span class="lineNum">     300 </span>            : }
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : /* This function is to be called by a conservative collision detection scheme when two object are very close */
<span class="lineNum">     304 </span>            : /* Conservative schemes do badly in this situation because the two objects will conservatively collide instantly */
<span class="lineNum">     305 </span><span class="lineNoCov">          0 : collision_t vertex_group::close_contact_collision_detection(vertex_group *const vg, simplex **const manifold_a, simplex **const manifold_b, fp_t *const t, const point_t &amp;noc) const</span>
<span class="lineNum">     306 </span>            : {
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     METHOD_LOG;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Determining exact collision time up to: &quot; &lt;&lt; *t;</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :     /* Check for objects moving together, if so they collide instantly */
<span class="lineNum">     311 </span>            :     // const fp_t va_dot_vb = dot_product(_v, vg-&gt;_v);
<span class="lineNum">     312 </span>            :     // if (va_dot_vb &lt; 0.0f)
<span class="lineNum">     313 </span>            :     // {
<span class="lineNum">     314 </span>            :     //     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Objects translating towards each other, instant impact&quot;;
<span class="lineNum">     315 </span>            :     //     *t = 0.0f;
<span class="lineNum">     316 </span>            :     //     return RESTING_COLLISION;
<span class="lineNum">     317 </span>            :     // }
<span class="lineNum">     318 </span>            :         
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     const point_t n((*manifold_a)-&gt;normal_of_impact(**manifold_b));</span>
<span class="lineNum">     320 </span>            :     // const point_t poc((*manifold_a)-&gt;center_of_impact(**manifold_b, n));
<span class="lineNum">     321 </span>            :     // if (va_dot_vb == 0.0f)
<span class="lineNum">     322 </span>            :     // {
<span class="lineNum">     323 </span>            :     //     //if (dot_product(_v, n) &lt; 0.0f)
<span class="lineNum">     324 </span>            :     //     if (dot_product(get_velocity(poc), n) &lt; 0.0f)
<span class="lineNum">     325 </span>            :     //     {
<span class="lineNum">     326 </span>            :     //         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Object a translating towards b, instant impact&quot;;
<span class="lineNum">     327 </span>            :     //         *t = 0.0f;
<span class="lineNum">     328 </span>            :     //         return RESTING_COLLISION;
<span class="lineNum">     329 </span>            :     //     }
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :     //     //if (dot_product(vg-&gt;_v, n) &gt; 0.0f)
<span class="lineNum">     332 </span>            :     //     if (dot_product(vg-&gt;get_velocity(poc), n) &gt; 0.0f)
<span class="lineNum">     333 </span>            :     //     {
<span class="lineNum">     334 </span>            :     //         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Objects b translating towards a, instant impact&quot;;
<span class="lineNum">     335 </span>            :     //         *t = 0.0f;
<span class="lineNum">     336 </span>            :     //         return RESTING_COLLISION;
<span class="lineNum">     337 </span>            :     //     }
<span class="lineNum">     338 </span>            :     // }
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :     /* Move the com to the origin for rotation */
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     (*_verts) -= _i-&gt;center_of_mass();</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     (*vg-&gt;_verts) -= vg-&gt;_i-&gt;center_of_mass();</span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     fp_t full_t = *t;</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     quaternion_t full_rot(project_rotation(full_t));</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     while (fabs(full_rot.w) &lt; 0.99f)</span>
<span class="lineNum">     348 </span>            :     {
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         full_t = (_cur_t + full_t) * 0.5f;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         full_rot = project_rotation(full_t);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Only testing up to time: &quot; &lt;&lt; full_t &lt;&lt; &quot; because of fast rotation&quot;;</span>
<span class="lineNum">     352 </span>            :     }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :     /* Initial relative state, less the safety margin */
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     const point_t x0(_i-&gt;center_of_mass() - vg-&gt;_i-&gt;center_of_mass() - (n * (0.25 * raptor_physics::WELD_DISTANCE)));</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     const fp_t r0 = 1.0f;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     const point_t q0(0.0f, 0.0f, 0.0f);</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :     /* Final relative state */
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     const point_t x1(x0 + project_translation(full_t) - vg-&gt;project_translation(full_t));</span>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     const quaternion_t rot(project_rotation(full_t));</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     const point_t q1(rot.x, rot.y, rot.z);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     const fp_t r1 = rot.w;</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Verts: &quot; &lt;&lt; _verts-&gt;size();</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Tris: &quot; &lt;&lt; vg-&gt;_tris-&gt;size();</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :     /* Check each vertex of this object */
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     const point_t nb(n);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     fp_t frac_t = 1.001f;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; _verts-&gt;size(); ++i)</span>
<span class="lineNum">     374 </span>            :     {
<span class="lineNum">     375 </span>            :         /* See when it is inside all face of vg */
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         const point_t pa(_verts-&gt;get_row(i));</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         for (int j = 0; j &lt; static_cast&lt;int&gt;(vg-&gt;_tris-&gt;size()); j += 3)</span>
<span class="lineNum">     378 </span>            :         {
<span class="lineNum">     379 </span>            :             /* Build face normal */
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :             const point_t pb_0(vg-&gt;_verts-&gt;get_row((*vg-&gt;_tris)[j]));</span>
<span class="lineNum">     381 </span>            :             // const point_t pb_1(vg-&gt;_verts-&gt;get_row((*vg-&gt;_tris)[j + 1]));
<span class="lineNum">     382 </span>            :             // const point_t pb_2(vg-&gt;_verts-&gt;get_row((*vg-&gt;_tris)[j + 2]));
<span class="lineNum">     383 </span>            :             // const point_t nb(cross_product(pb_1 - pb_0, pb_2 - pb_0));
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :             /* Find intersection time */
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :             const fp_t inter = find_exact_collision_time(pa, pb_0, nb, x0, x1, q0, q1, r0, r1);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :             frac_t = std::min(frac_t, inter);</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :             BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Determining exact collision time up to: &quot; &lt;&lt; (full_t * frac_t);</span>
<span class="lineNum">     389 </span>            :         }
<span class="lineNum">     390 </span>            :     }
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :     /* Return to the com */
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     (*_verts) += _i-&gt;center_of_mass();</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     (*vg-&gt;_verts) += vg-&gt;_i-&gt;center_of_mass();</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Exact collision time at: &quot; &lt;&lt; (full_t * frac_t);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     if (frac_t &lt;= 1.0f) </span>
<span class="lineNum">     398 </span>            :     {
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Resting collision&quot;;</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         (*t) = 0.0;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         return RESTING_COLLISION;</span>
<span class="lineNum">     402 </span>            :     }
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     else if (full_t &lt; *t)</span>
<span class="lineNum">     404 </span>            :     {
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         *t = full_t;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;No collision in time limit, requesting retest at limit&quot;;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         return POSSIBLE_COLLISION;</span>
<span class="lineNum">     408 </span>            :     }
<span class="lineNum">     409 </span>            :     else
<span class="lineNum">     410 </span>            :     {
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;No collision&quot;;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         return NO_COLLISION;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     414 </span>            : }
<a name="415"><span class="lineNum">     415 </span>            : </a>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineCov">         48 : vertex_group&amp; vertex_group::commit_movement(const fp_t t)</span>
<span class="lineNum">     418 </span>            : {
<span class="lineNum">     419 </span>            :     /* Move the com to the origin for rotation */
<span class="lineNum">     420 </span><span class="lineCov">         48 :     (*_verts) -= _i-&gt;center_of_mass();</span>
<span class="lineNum">     421 </span>            :     
<span class="lineNum">     422 </span>            :     /* Rotate */
<span class="lineNum">     423 </span><span class="lineCov">         48 :     point_t vel;</span>
<span class="lineNum">     424 </span><span class="lineCov">         48 :     const quaternion_t ang_dis(project_rotation(&amp;vel, t));</span>
<span class="lineNum">     425 </span>            :     // BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Average angular vel.: &quot; &lt;&lt; ang_dis;
<span class="lineNum">     426 </span>            :     // BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;New angular vel.: &quot; &lt;&lt; vel;
<span class="lineNum">     427 </span><span class="lineCov">         48 :     _verts-&gt;rotate_all_about_origin(ang_dis);</span>
<span class="lineNum">     428 </span><span class="lineCov">         48 :     _w = vel;</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :     /* Update the orientation */
<span class="lineNum">     431 </span><span class="lineCov">         48 :     _o *= ang_dis;</span>
<span class="lineNum">     432 </span>            :     //normalise(&amp;_o);
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :     /* Translate, including returning the com */
<span class="lineNum">     435 </span><span class="lineCov">         48 :     _i-&gt;move_center_of_mass(project_translation(&amp;vel, t));</span>
<span class="lineNum">     436 </span><span class="lineCov">         48 :     (*_verts) += _i-&gt;center_of_mass();</span>
<span class="lineNum">     437 </span><span class="lineCov">         48 :     _v = vel;</span>
<span class="lineNum">     438 </span>            :     //BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Velocity: &quot; &lt;&lt; _v.x &lt;&lt; &quot; &quot; &lt;&lt; _v.y &lt;&lt; &quot; &quot; &lt;&lt; _v.z;
<span class="lineNum">     439 </span>            :     
<span class="lineNum">     440 </span>            :     /* Update time */
<span class="lineNum">     441 </span><span class="lineCov">         48 :     _cur_t = t;</span>
<span class="lineNum">     442 </span>            :     
<span class="lineNum">     443 </span><span class="lineCov">         48 :     return *this;</span>
<span class="lineNum">     444 </span>            : }
<a name="445"><span class="lineNum">     445 </span>            : </a>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineCov">       1872 : point_t vertex_group::project_translation(const fp_t t) const</span>
<span class="lineNum">     448 </span>            : {
<span class="lineNum">     449 </span><span class="lineCov">       1872 :     point_t vel;</span>
<span class="lineNum">     450 </span><span class="lineCov">       1872 :     return project_translation(&amp;vel, t);</span>
<span class="lineNum">     451 </span>            : }
<a name="452"><span class="lineNum">     452 </span>            : </a>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineCov">       1920 : point_t vertex_group::project_translation(point_t *const vel, const fp_t t) const</span>
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span>            :     /* Time relative to this vertex group */
<span class="lineNum">     457 </span><span class="lineCov">       1920 :     const fp_t t_step = std::max(static_cast&lt;fp_t&gt;(0.0), t - _cur_t);</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :     /* Acceleration */
<span class="lineNum">     460 </span>            :     /* F = MA -&gt; A = F/M */
<span class="lineNum">     461 </span><span class="lineCov">       1920 :     const point_t a(_f / _i-&gt;mass());</span>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            :     /* Velocity */
<span class="lineNum">     464 </span>            :     /* V = U + (A * t) */
<span class="lineNum">     465 </span><span class="lineCov">       1920 :     (*vel) = _v + (a * t_step);</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :     /* Translation */
<span class="lineNum">     468 </span><span class="lineCov">       1920 :     return (_v + (*vel)) * (t_step * 0.5);</span>
<span class="lineNum">     469 </span>            : }
<a name="470"><span class="lineNum">     470 </span>            : </a>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineNoCov">          0 : quaternion_t vertex_group::project_rotation(const fp_t t) const</span>
<span class="lineNum">     473 </span>            : {
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     point_t vel;</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     return project_rotation(&amp;vel, t);</span>
<span class="lineNum">     476 </span>            : }
<a name="477"><span class="lineNum">     477 </span>            : </a>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineCov">         48 : quaternion_t vertex_group::project_rotation(point_t *const vel, const fp_t t) const</span>
<span class="lineNum">     480 </span>            : {
<span class="lineNum">     481 </span>            :     /* Time relative to this vertex group */
<span class="lineNum">     482 </span><span class="lineCov">         48 :     const fp_t t_step = std::max(static_cast&lt;fp_t&gt;(0.0), t - _cur_t);</span>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :     /* Acceleration */
<span class="lineNum">     485 </span>            :     /* F = MA -&gt; A = F/M */
<span class="lineNum">     486 </span><span class="lineCov">         48 :     const point_t a(_tor / (*_i));</span>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :     /* Velocity */
<span class="lineNum">     489 </span>            :     /* V = U + (A * t) */
<span class="lineNum">     490 </span><span class="lineCov">         48 :     (*vel) = _w + (a * t_step);</span>
<span class="lineNum">     491 </span>            :     
<span class="lineNum">     492 </span>            :     /*
<span class="lineNum">     493 </span>            :     const point_t avg_w((_w + (*vel)) * 0.5);
<span class="lineNum">     494 </span>            :     const quaternion_t w_quat(0.5 * quaternion_t(0.0, avg_w.x, avg_w.y, avg_w.z) * _o);
<span class="lineNum">     495 </span>            :     std::cout &lt;&lt; &quot;avg_w: &quot; &lt;&lt; avg_w &lt;&lt; &quot; w_quat: &quot; &lt;&lt; w_quat &lt;&lt; &quot; _o: &quot; &lt;&lt; _o &lt;&lt; &quot; *: &quot; &lt;&lt; (quaternion_t(0.0, avg_w.x, avg_w.y, avg_w.z) * _o) &lt;&lt; std::endl;
<span class="lineNum">     496 </span>            :     return w_quat * t_step;
<span class="lineNum">     497 </span>            :     */    
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :     /* Rotate */
<span class="lineNum">     500 </span><span class="lineCov">         48 :     return quaternion_t((_w + (*vel)) * (t_step * 0.5));</span>
<span class="lineNum">     501 </span>            : }
<a name="502"><span class="lineNum">     502 </span>            : </a>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span><span class="lineCov">         48 : fp_t vertex_group::project_maximum_rotation_onto(const point_t &amp;n, const point_t &amp;p, const fp_t t) const</span>
<span class="lineNum">     505 </span>            : {
<span class="lineNum">     506 </span>            :     /* Time relative to this vertex group */
<span class="lineNum">     507 </span><span class="lineCov">         48 :     const fp_t t_step = std::max(static_cast&lt;fp_t&gt;(0.0), t - _cur_t);</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :     /* Acceleration */
<span class="lineNum">     510 </span>            :     /* F = MA -&gt; A = F/M */
<span class="lineNum">     511 </span><span class="lineCov">         48 :     const point_t ang_a(_tor / _i-&gt;mass());</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            :     /* Velocity */
<span class="lineNum">     514 </span>            :     /* V = U + (A * t) */
<span class="lineNum">     515 </span><span class="lineCov">         48 :     const point_t ang_vel(_w + (ang_a * t_step));</span>
<span class="lineNum">     516 </span><span class="lineCov">         48 :     const point_t avg_ang_vel((_w + ang_vel) * t_step * 0.5);</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :     /* Find the vertex moving the most along n */
<span class="lineNum">     519 </span>            :     fp_t max_rot;
<span class="lineNum">     520 </span><span class="lineCov">         48 :     const point_t w_cross_n(cross_product(avg_ang_vel, n));</span>
<span class="lineNum">     521 </span>            : //    BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;n: &quot; &lt;&lt; n.x &lt;&lt; &quot; &quot; &lt;&lt; n.y &lt;&lt; &quot; &quot; &lt;&lt; n.z;
<span class="lineNum">     522 </span>            : //    BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;w cross n: &quot; &lt;&lt; w_cross_n.x &lt;&lt; &quot; &quot; &lt;&lt; w_cross_n.y &lt;&lt; &quot; &quot; &lt;&lt; w_cross_n.z;
<span class="lineNum">     523 </span>            :     //const int rot_pot = raptor_physics::find_support_vertex(*_verts, w_cross_n, _i-&gt;center_of_mass(), p, n, &amp;max_rot);
<span class="lineNum">     524 </span><span class="lineCov">         48 :     raptor_physics::find_support_vertex(*_verts, avg_ang_vel, _i-&gt;center_of_mass(), p, n, &amp;max_rot);</span>
<span class="lineNum">     525 </span>            : //    BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;Most rotating point: &quot; &lt;&lt; _verts-&gt;get_row(rot_pot).x &lt;&lt; &quot; &quot;  &lt;&lt; _verts-&gt;get_row(rot_pot).y &lt;&lt; &quot; &quot; &lt;&lt; _verts-&gt;get_row(rot_pot).z;
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">         48 :     return max_rot;</span>
<span class="lineNum">     528 </span>            : }
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineCov">         24 : fp_t vertex_group::project_maximum_movement_onto(const vertex_group &amp;v, const point_t &amp;p_a, const point_t &amp;p_b, const point_t &amp;n, const fp_t t) const</span>
<span class="lineNum">     532 </span>            : {
<span class="lineNum">     533 </span>            :     /* Translation */
<span class="lineNum">     534 </span><span class="lineCov">         24 :     const point_t tra_rel(v.project_translation(t) - project_translation(t));</span>
<span class="lineNum">     535 </span><span class="lineCov">         24 :     const fp_t tra = dot_product(tra_rel, n);</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :     /* Rotation */
<span class="lineNum">     538 </span><span class="lineCov">         24 :     const fp_t rot = v.project_maximum_rotation_onto(-n, p_b, t) + project_maximum_rotation_onto(n, p_a, t);</span>
<span class="lineNum">     539 </span><span class="lineCov">         48 :     BOOST_LOG_TRIVIAL(trace) &lt;&lt; &quot;tra: &quot; &lt;&lt; tra &lt;&lt; &quot; rot: &quot; &lt;&lt; rot;</span>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :     /* Total */
<a name="542"><span class="lineNum">     542 </span><span class="lineCov">         24 :     return tra + rot;</span></a>
<span class="lineNum">     543 </span>            : }
<span class="lineNum">     544 </span><span class="lineCov">         36 : }; /* namespace raptor_physics */</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
