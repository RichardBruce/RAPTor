#include "perlin_noise_3d.h"

/***********************************************************
 noise takes a point x, y, z and returns a random value for
 this point.
 
 The same value will be returned for the same point everytime.
 The return value will be in the range -1 to 1
************************************************************/
float perlin_noise_3d::noise(const int x, const int y, const int z) const
{
    int n = x + y * 57 + z * 13 + this->_s;
    n = (n << 13) ^ n;
    return static_cast<float>(1.0f - ((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0f);
}


/***********************************************************
  smooth_noise generates smoothed noise at a point x, y, z.
  The value of the smooth noise is return. For a given point
  the return value will always be the same.
  
  The smoothed noise is generated by taking noise values at 
  the center and the center of the faces of a 2 unit cube.
  These values are weighted and added.
************************************************************/
float perlin_noise_3d::smooth_noise(const int x, const int y, const int z) const
{
    const float sides  = (noise(x - 1, y,   z    ) + noise(x + 1, y,   z    ) + noise(x,   y - 1,  z ) + noise(x,   y + 1, z  ) + 
                          noise(x,     y,   z - 1) + noise(x,     y,   z + 1)) * (1.0f / 16.0f);

    const float center =  noise(x, y, z) * (1.0f / 4.0f);
    return sides + center;
}


/***********************************************************
  interpolate takes two values a and b and the desired 
  points distance from a. The interpolated value is returned.
  
  Cos interpolation is used for the interpolation function.
************************************************************/
float perlin_noise_3d::interpolate(const float a, const float b, const float x) const
{
    const float ft = x * PI;
    const float f = (1.0f - std::cos(ft)) * 0.5f;

    return  a * (1.0f - f) + b * f;
}


/***********************************************************
  interpolated_noise generates and interpolates the noise 
  field.
  
  Smoothed noise values are generated at the 8 vertices of a
  two unit cube and then interploted.
************************************************************/
float perlin_noise_3d::interpolated_noise(const float x, const float y, const float z) const
{
    /* Get integer and fractional componants of x, y and z */
    const int wx    = (int)(static_cast<float>((int)x) + 0.5f);
    const float px  = x - wx;

    const int wy    = (int)(static_cast<float>((int)y) + 0.5f);
    const float py  = y - wy;

    const int wz    = (int)(static_cast<float>((int)z) + 0.5f);
    const float pz  = z - wz;

    /* Generate smooted noise on a 2 unit cube */
    const float v1 = smooth_noise(wx,     wy,     wz    );
    const float v2 = smooth_noise(wx + 1, wy,     wz    );
    const float v3 = smooth_noise(wx,     wy + 1, wz    );
    const float v4 = smooth_noise(wx + 1, wy + 1, wz    );
    const float v5 = smooth_noise(wx,     wy,     wz + 1);
    const float v6 = smooth_noise(wx + 1, wy,     wz + 1);
    const float v7 = smooth_noise(wx,     wy + 1, wz + 1);
    const float v8 = smooth_noise(wx + 1, wy + 1, wz + 1);

    /* Interpolate within the cube */
    const float ix0 = interpolate(v1, v2, px);
    const float ix1 = interpolate(v3, v4, px);
    const float ix2 = interpolate(v5, v6, px);
    const float ix3 = interpolate(v7, v8, px);

    const float iy0 = interpolate(ix0, ix1, py);
    const float iy1 = interpolate(ix2, ix3, py);
    return interpolate(iy0, iy1, pz);
}
